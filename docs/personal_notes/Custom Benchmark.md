# Benchmark module
Explanation of the benchmark module and its usage.
(Explaination generated by ChatGPT -> content to edit/fix by user)
---

# Using C++ Lambdas with Captures in a C Benchmark API

This document explains step by step how `benchmark_cpp_trampoline` works and how captured variables are handled when calling a C++ lambda from a C API.

---

## 1. The C Benchmark API

```c
typedef void (*bench_fn_t)(void *userdata);

bench_result_t benchmark_run_c(bench_fn_t fn, void* userdata, bench_params_t params);
```

- `fn` is a plain C function pointer (`void(*)(void*)`)
- `userdata` is a void pointer that can carry any data
- Standard C pattern for callbacks with state

---

## 2. The C++ Lambda

```cpp
int N = 1000;
double dt = 0.01;
auto lambda = [=] { simulate_step(N, dt); };
bench_result_t result = benchmark_run(lambda, { .iterations = 50 });
```

- Lambda captures `N` and `dt` by value
- Compiler generates a unique closure class:

```cpp
class __lambda_0 {
    int N;
    double dt;
public:
    void operator()() const { simulate_step(N, dt); }
};
```

- Lambda object stores the captured variables internally

---

## 3. Wrap the Lambda in `std::function`

```cpp
std::function<void()> fn = lambda;
benchmark_run_c(benchmark_cpp_trampoline, &fn, params);
```

- `std::function<void()>` type-erases the lambda
- `&fn` is a pointer passed as `void* userdata` to the C function
- `std::function` manages captured variables internally

---

## 4. Call into the C API

- `benchmark_run_c` is pure C and calls `fn(userdata)`
- C sees only `void*` and function pointer
- This is the bridge between C and C++

---

## 5. The Trampoline Function

```cpp
extern "C" inline void benchmark_cpp_trampoline(void* userdata)
{
    auto* fn = reinterpret_cast<std::function<void()>*>(userdata);
    (*fn)();
}
```

Step by step:
1. `extern "C"` ensures C linkage (no name mangling)
2. `userdata` is cast back to `std::function<void()>*`
3. `(*fn)()` calls the lambda object, which has the captures stored

---

## 6. Full Wrapping Pipeline

```
[C++ lambda with captures] --> [std::function<void()> fn]
       stores captured variables inside object
                   |
                   v
       &fn passed as void* to C API
                   |
                   v
[C function benchmark_run_c] calls fn(userdata)
                   |
                   v
[trampoline: benchmark_cpp_trampoline(void* userdata)]
                   |
   cast back to std::function<void()>*
                   |
                   v
       (*fn)()  --> calls lambda's operator()
                   |
                   v
    lambda operator() executes code using captured variables
```

---

## 7. How Captured Variables Survive

- Captures are stored inside the lambda object
- `std::function` stores the object internally
- Calling `(*fn)()` invokes `operator()` on the stored lambda, giving access to all captured variables

No special effort is needed — the trampoline just casts the pointer and calls `operator()`

---

## 8. Why It Works

1. `void*` is an opaque pointer
2. `extern "C"` guarantees a C ABI for the trampoline
3. `reinterpret_cast` recovers the C++ object
4. `std::function` manages lifetime and captures
5. Lambda `operator()` executes with all captures intact

---

## 9. Summary Table

| Step | What happens | Key point |
|------|--------------|-----------|
| Lambda creation | `[=]{ ... }` | Closure object stores captured variables |
| Wrap in std::function | `std::function<void()> fn = lambda` | Type-erased callable object |
| Pass to C API | `benchmark_run_c(trampoline, &fn)` | C sees only void* |
| C calls trampoline | `benchmark_cpp_trampoline(void* userdata)` | `extern "C"` → C ABI |
| Trampoline casts | `auto* fn = reinterpret_cast<std::function<void()>*>(userdata)` | Restores C++ object |
| Invoke | `(*fn)()` | Calls lambda with captures |
| Execution | Lambda executes | Captures accessible inside closure |

---

This pipeline allows **C++ lambdas with captures to be called safely from C code** while preserving captured state.

---

**Optional diagram for memory flow:**

```
+---------------------+
| Lambda closure obj  | <- stores captured variables
+---------------------+
            |
            v
+---------------------+
| std::function<void()>| <- type-erased callable
+---------------------+
            |
            v
  void* userdata passed to C API
            |
            v
+---------------------+
| C trampoline        |
| extern "C"         |
+---------------------+
            |
            v
  Call (*fn)() -> invokes lambda with captures
```

